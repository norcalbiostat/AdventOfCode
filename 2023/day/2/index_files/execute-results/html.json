{
  "hash": "801bb6ae33a6d5ec0506c3b869a053de",
  "result": {
    "markdown": "---\ntitle: \"2023: Day 2 - Cube Conundrum\"\ndate: 2023-12-2\ncategories:\n  - dplyr\n  - tidyr\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/2)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aochelpers)\nlibrary(tidyr)\nlibrary(dplyr)\ninput <- aoc_input_data_frame(2, 2023)\nhead(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n  X1     X2                                                                     \n  <chr>  <chr>                                                                  \n1 Game 1 \" 1 green, 4 blue; 1 blue, 2 green, 1 red; 1 red, 1 green, 2 blue; 1 g…\n2 Game 2 \" 2 blue, 2 red, 6 green; 1 red, 6 green, 7 blue; 10 green, 8 blue, 1 …\n3 Game 3 \" 6 green, 5 blue, 9 red; 4 blue, 1 green, 13 red; 9 green, 14 red, 1 …\n4 Game 4 \" 14 green, 3 blue, 16 red; 20 red; 4 green, 2 red, 1 blue; 10 blue, 1…\n5 Game 5 \" 5 green, 4 blue; 1 red, 3 blue, 2 green; 4 green, 2 red, 15 blue; 11…\n6 Game 6 \" 6 blue, 10 green; 2 red, 6 green, 2 blue; 4 red, 4 blue, 1 green; 2 …\n```\n:::\n\n```{.r .cell-code}\nnames(input) <- c(\"game\", \"set\")\n```\n:::\n\n\n# TLDR; Solutions\n\n## Part 1 ⭐\n\n::: callout-danger\n### ❓Which games would have been possible if the bag contained only 12 red cubes, 13 green cubes, and 14 blue cubes?\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.results <- input |> \n\t# get game numbers\n\tmutate(game = as.numeric(gsub(\"Game \",\"\", game))) |>\n\t# split out the sets\n\tseparate_wider_delim(set, delim = \";\", names_sep = \"\", too_few = \"align_start\") |>\n\t# one row per set\n\tpivot_longer(contains(\"set\"), names_to = \"set\", values_to = \"cube\") |>\n\t# split out the colors\n\tseparate_wider_delim(cube, delim = \",\", names_sep = \"\", too_few = \"align_start\") |>\n\t# one row per cube\n\tpivot_longer(cube1:cube3, names_to = \"cube\", values_to = \"color\") |>\n\t# cleanup\n\tmutate(color = trimws(color)) |>\n\tselect(-cube) |> \n\tna.omit() |>\n\t# split out number of colors now\n\tseparate_wider_delim(color, delim = \" \", names_sep = \"\", too_few = \"align_start\") |>\n\tmutate(color1 = as.numeric(color1)) |>\n\t# put colors into separate columns\n\tpivot_wider(names_from = color2, values_from = color1) |>\n\treplace_na(list(blue=0, red=0, green=0))\n\n\tset.results %>%\n\tmutate(validity = ifelse(red >12 | green > 13 | blue >14, \n\t\t\t\t\t\t\t\t\t\t\t\t\t \"invalid\", \"valid\")) |>\n\t# flag games with invalid combos\n\tgroup_by(game) |> summarize(n.invalid = sum(validity==\"invalid\")) |>\n\t# keep only valid games\n\tungroup() |>\n\tfilter(n.invalid ==0) |>\n\t# solution input is the sum of valid game numbers\n\tsummarise(sum(game))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  `sum(game)`\n        <dbl>\n1        2486\n```\n:::\n:::\n\n\n## Part 2 ⭐⭐\n\n::: callout-danger\n### ❓What is the fewest number of cubes of each color that could have been in the bag to make the game possible?\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.results |> \n\tgroup_by(game) |>\n\t# find max number of each color per game\n\tsummarize(min.green = max(green), \n\t\t\t\t min.red = max(red), \n\t\t\t\t min.blue = max(blue)) |>\n\t# calculate submission value\n\tmutate(power = min.green*min.red*min.blue) |>\n\tsummarize(sum(power))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  `sum(power)`\n         <dbl>\n1        87984\n```\n:::\n:::\n\n\n# Walkthrough / Explainer\n\nI was launched successfully to Snow Island, which has a noticeable lack of snow. While we're walking I'm playing a game with a local Elf. \"Guess how many cubes are in the bag\". Kinda..\n\n## Part 1\n\n:::{.callout-exa icon=true} Example Data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexa <- data.frame(input = \n\t\tc(\"Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green\", \n\t\t\t\"Game 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue\",\n   \t\t\"Game 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red\",\n   \t\t\"Game 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red\",\n   \t\t\"Game 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green\"))\n\nexa <- exa |> \n\tseparate_wider_delim(input, delim = \":\", names = c(\"game\", \"set\"))\n```\n:::\n\n:::\n\nMy solution I think is going to use a series of `separates` and `pivot`ing to get the games as rows, colors on the columns and number of colors as values. Then I can compare each row with the total number of cubes to see which games were possible. \n\nGet number of each color cube per game/set combo.\n\n::: {.cell}\n\n```{.r .cell-code}\n\t# get game numbers\nset.results <- input |> \n\tmutate(game = as.numeric(gsub(\"Game \",\"\", game))) |>\n\t# split out the sets\n\tseparate_wider_delim(set, delim = \";\", names_sep = \"\", too_few = \"align_start\") |>\n\t# one row per set\n\tpivot_longer(contains(\"set\"), names_to = \"set\", values_to = \"cube\") |>\n\t# split out the colors\n\tseparate_wider_delim(cube, delim = \",\", names_sep = \"\", too_few = \"align_start\") |>\n\t# one row per cube\n\tpivot_longer(cube1:cube3, names_to = \"cube\", values_to = \"color\") |>\n\t# cleanup\n\tmutate(color = trimws(color)) |>\n\tselect(-cube) |> \n\tna.omit() |>\n\t# split out number of colors now\n\tseparate_wider_delim(color, delim = \" \", names_sep = \"\", too_few = \"align_start\") |>\n\tmutate(color1 = as.numeric(color1)) |>\n\t# put colors into separate columns\n\tpivot_wider(names_from = color2, values_from = color1) |>\n\treplace_na(list(blue=0, red=0, green=0))\n\nhead(set.results)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 5\n   game set   green  blue   red\n  <dbl> <chr> <dbl> <dbl> <dbl>\n1     1 set1      1     4     0\n2     1 set2      2     1     1\n3     1 set3      1     2     1\n4     1 set4      1     0     1\n5     1 set5      1     0     0\n6     1 set6      1     1     1\n```\n:::\n:::\n\n\nNow compare each set result against the proposed pool of 12 red cubes, 13 green cubes, and 14 blue cubes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.results %>%\n\tmutate(validity = ifelse(red >12 | green > 13 | blue >14, \n\t\t\t\t\t\t\t\t\t\t\t\t\t \"invalid\", \"valid\")) |>\n\t# flag games with invalid combos\n\tgroup_by(game) |> summarize(n.invalid = sum(validity==\"invalid\")) |>\n\t# keep only valid games\n\tungroup() |>\n\tfilter(n.invalid ==0) |>\n\t# solution input is the sum of valid game numbers\n\tsummarise(sum(game))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  `sum(game)`\n        <dbl>\n1        2486\n```\n:::\n:::\n\n\n⭐\n\n\n## Part 2\n\nSo I find out that much like California, they're in a drought. So no water, no snow. So while we go check on the water, the elf asks another question about said game. What is the fewest number of cubes of each color that could have been in the bag to make the game possible?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.results |> \n\tgroup_by(game) |>\n\t# find max number of each color per game\n\tsummarize(min.green = max(green), \n\t\t\t\t min.red = max(red), \n\t\t\t\t min.blue = max(blue)) |>\n\t# calculate submission value\n\tmutate(power = min.green*min.red*min.blue) |>\n\tsummarize(sum(power))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n  `sum(power)`\n         <dbl>\n1        87984\n```\n:::\n:::\n\n\nRight on the first try! Today's challenge was relativly straight forward, and my approach to the first challenge made the second part very easy. \n\n⭐⭐\n\n##### Session info {.appendix}\n\n<details>\n\n<summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.1 (2023-06-16 ucrt)\n os       Windows 11 x64 (build 22000)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Los_Angeles\n date     2023-12-02\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package    * version    date (UTC) lib source\n aochelpers * 0.1.0.9000 2023-11-30 [1] Github (EllaKaye/aochelpers@c2afc01)\n dplyr      * 1.1.2      2023-04-20 [1] CRAN (R 4.3.1)\n tidyr      * 1.3.0      2023-01-24 [1] CRAN (R 4.3.1)\n\n [1] C:/Users/renta/AppData/Local/R/win-library/4.3\n [2] C:/Program Files/R/R-4.3.1/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n\n</details>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}