{
  "hash": "4634156b0613bc5aa6628dd9bc013cb1",
  "result": {
    "markdown": "---\ntitle: \"2023: Day 1\"\ndate: 2023-12-1\ncategories:\n  - regex\n  - loop\n  - stringr\n  - stringi\n  - peeked\ndraft: false\n---\n\n\n# Setup\n\n[The original challenge](https://adventofcode.com/2023/day/1)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aochelpers) # for data loading\nlibrary(stringr); library(stringi)\ninput <- aoc_input_vector(1, 2023)\n```\n:::\n\n\n# TLDR; Solutions\n\n## Part 1 â­\n\n::: {.callout-danger}\n### â“  What is my calibration number? \n\nOn each line, the calibration value can be found by combining the first digit and the last digit (in that order) to form a single two-digit number.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnums <- gsub(\"[a-z]\", \"\", input)\nfirst.num <- str_extract(nums, \"^.\")\nlast.num <- str_extract(nums, \".$\")\nas.numeric(paste0(first.num, last.num)) |> sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55386\n```\n:::\n:::\n\n\n## Part 2 â­â­\n\n::: {.callout-danger}\n### â“ What is my  _actual_ calibration number? \n\n> Your calculation isn't quite right. It looks like some of the digits are actually spelled out with letters: one, two, three, four, five, six, seven, eight, and nine also count as valid \"digits\". \n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalid <- c(\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\", as.character(1:9))\nvalid.num <- c(1:9,1:9) \n\nN <- length(input)\nnew.cal.vals <- rep(0, N)\n\nfor(i in 1:N){\n\tx <- stri_locate_all_regex(input[i], valid)\n\tx.first <- lapply(x, head, 1) |> unlist() |> matrix(ncol=2, byrow=TRUE)\n\tx.last  <- lapply(x, tail, 1) |> unlist() |> matrix(ncol=2, byrow=TRUE)\n\tfirst <- which.min(x.first[,1])\n\tlast  <- which.max(x.last[,2])\n\tnew.cal.vals[i] <- as.numeric(paste0(valid.num[first], valid.num[last]))\n}\nsum(new.cal.vals)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 54824\n```\n:::\n:::\n\n\n# Walkthrough / Explainer\n\n## Part 1\n\n:::{.callout-exa icon=true}\nExample Data\n\n::: {.cell}\n\n```{.r .cell-code}\nexa <- c(\"1abc2\",\"pqr3stu8vwx\",\"a1b2c3d4e5f\",\"treb7uchet\")\n```\n:::\n\n\n:::\n\nRemove all characters from the string, then grab the first and last number.\n\n::: {.cell}\n\n```{.r .cell-code}\nnums <- gsub(\"[a-z]\", \"\", input)\nfirst.num <- str_extract(nums, \"^.\")\nlast.num <- str_extract(nums, \".$\")\ncbind(nums, first.num, last.num)[c(1,4,300,304),] # verify\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     nums    first.num last.num\n[1,] \"9\"     \"9\"       \"9\"     \n[2,] \"57\"    \"5\"       \"7\"     \n[3,] \"934\"   \"9\"       \"4\"     \n[4,] \"83858\" \"8\"       \"8\"     \n```\n:::\n:::\n\n\nPaste together to create the two-digit calibration number.\n\n::: {.cell}\n\n```{.r .cell-code}\ncalibration.value <- as.numeric(paste0(first.num, last.num))\ncbind(nums, first.num, last.num, calibration.value)[c(1,4,300,304),] \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     nums    first.num last.num calibration.value\n[1,] \"9\"     \"9\"       \"9\"      \"99\"             \n[2,] \"57\"    \"5\"       \"7\"      \"57\"             \n[3,] \"934\"   \"9\"       \"4\"      \"94\"             \n[4,] \"83858\" \"8\"       \"8\"      \"88\"             \n```\n:::\n:::\n\n\nSubmission value: \n\n::: {.cell}\n\n```{.r .cell-code}\nsum(calibration.value) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 55386\n```\n:::\n:::\n\n\nâ­\n\n## Part 2\n\n:::{.callout-exa icon=true}\nExample Data\n\n::: {.cell}\n\n```{.r .cell-code}\nexa2 <- c(\"two1nine\",\n  \"eightwothree\",\n  \"abcone2threexyz\",\n  \"xtwone3four\",\n  \"4nineeightseven2\",\n  \"zoneight234\",\n  \"7pqrstsixteen\", \n  \"7eight7\",     # 2 new test cases\n  \"3stuffthree\")\n```\n:::\n\n\n:::\n\nOkay, so let's define a list of valid 'digits', and their corresponding numeric values. \n\n::: {.cell}\n\n```{.r .cell-code}\nvalid <- c(\"one\",\"two\",\"three\",\"four\",\"five\",\"six\",\"seven\",\"eight\",\"nine\", as.character(1:9))\nvalid.num <- c(1:9,1:9) \n```\n:::\n\n\nAnd find where in the strings these valid values are located. \n`stri_locate_first_regex` find the indexes (positions) where there is a match to some pattern. \nI learned about this function from [Gus Lipkin's solution](https://adventofcode.guslipkin.me/2023/01/2023-01)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- stri_locate_first_regex(exa2[1], valid)\nfirst <- which.min(x[,1])\nlast  <- which.max(x[,2])\ncal.val <- as.numeric(paste0(valid.num[first], valid.num[last]))\n```\n:::\n\n\nSo that gives me the correct first value. Now I need to apply this to each row. It's late, I'm tired so I'm gonna loop it. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- length(exa2)\nnew.cal.vals <- rep(0, n)\nfor(i in 1:n){\n\tx <- stri_locate_first_regex(exa2[i], valid)\n\tfirst <- which.min(x[,1])\n\tlast  <- which.max(x[,2])\n\tnew.cal.vals[i] <- as.numeric(paste0(valid.num[first], valid.num[last]))\n}\ncbind(exa2, new.cal.vals)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      exa2               new.cal.vals\n [1,] \"two1nine\"         \"29\"        \n [2,] \"eightwothree\"     \"83\"        \n [3,] \"abcone2threexyz\"  \"13\"        \n [4,] \"xtwone3four\"      \"24\"        \n [5,] \"4nineeightseven2\" \"42\"        \n [6,] \"zoneight234\"      \"14\"        \n [7,] \"7pqrstsixteen\"    \"76\"        \n [8,] \"7eight7\"          \"78\"        \n [9,] \"3stuffthree\"      \"33\"        \n```\n:::\n\n```{.r .cell-code}\nsum(new.cal.vals)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 392\n```\n:::\n:::\n\n\nHooray! This matches the example solution. Now to do this for my actual data. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(new.cal.vals, x, first, last, i) # just cos\nN <- length(input)\nnew.cal.vals <- rep(0, N)\nfor(i in 1:N){\n\tx <- stri_locate_first_regex(input[i], valid)\n\tfirst <- which.min(x[,1])\n\tlast  <- which.max(x[,2])\n\tnew.cal.vals[i] <- as.numeric(paste0(valid.num[first], valid.num[last]))\n}\nsum(new.cal.vals)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 54759\n```\n:::\n:::\n\n\nâŒ Nope. So I realized I was only using `stri_locate_first_regex` key is **first**. And so I was missing duplicates. I added a couple test cases `7eight7` and `3stuffthree`, and sure enough the last 7 wasn't getting caught. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- length(exa2)\nnew.cal.vals <- rep(0, n)\nfor(i in 1:n){\n\tx <- stri_locate_all_regex(exa2[i], valid)\n\ty <- unlist(x) |> matrix(ncol=2, byrow=TRUE) #the output of _all_ was different\n\tfirst <- which.min(y[,1])\n\tlast  <- which.max(y[,2])\n\tnew.cal.vals[i] <- as.numeric(paste0(valid.num[first], valid.num[last]))\n}\ncbind(exa2, new.cal.vals)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      exa2               new.cal.vals\n [1,] \"two1nine\"         \"29\"        \n [2,] \"eightwothree\"     \"83\"        \n [3,] \"abcone2threexyz\"  \"13\"        \n [4,] \"xtwone3four\"      \"24\"        \n [5,] \"4nineeightseven2\" \"42\"        \n [6,] \"zoneight234\"      \"14\"        \n [7,] \"7pqrstsixteen\"    \"76\"        \n [8,] \"7eight7\"          \"77\"        \n [9,] \"3stuffthree\"      \"33\"        \n```\n:::\n\n```{.r .cell-code}\nsum(new.cal.vals)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 391\n```\n:::\n:::\n\n\nLooks promising. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(new.cal.vals, x, first, last, i, y, N) # just cos\nN <- length(input)\nnew.cal.vals <- rep(0, N)\nfor(i in 1:N){\n\tx <- stri_locate_all_regex(input[i], valid)\n\ty <- unlist(x) |> matrix(ncol=2, byrow=TRUE) \n\tfirst <- which.min(y[,1])\n\tlast  <- which.max(y[,2])\n\tnew.cal.vals[i] <- as.numeric(paste0(valid.num[first], valid.num[last]))\n}\nsum(new.cal.vals)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nUhm...if there were some rows without numbers, this should have failed earlier...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.miss <- which(is.na(new.cal.vals))\ninput[is.miss][1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"9sixqnine9jk9six\"             \"58qtpqqz58888cmhs\"           \n[3] \"88trnvjtqsmseight8\"           \"962sixoneonectfgpknl8nine\"   \n[5] \"twotwosevenvkzzhrpgninecqvf9\"\n```\n:::\n:::\n\n\nYea... no those for sure have numbers. Well heck. What is my function doing?  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n(x <- stri_locate_all_regex(input[is.miss[1]], valid))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n     start end\n[1,]    NA  NA\n\n[[2]]\n     start end\n[1,]    NA  NA\n\n[[3]]\n     start end\n[1,]    NA  NA\n\n[[4]]\n     start end\n[1,]    NA  NA\n\n[[5]]\n     start end\n[1,]    NA  NA\n\n[[6]]\n     start end\n[1,]     2   4\n[2,]    14  16\n\n[[7]]\n     start end\n[1,]    NA  NA\n\n[[8]]\n     start end\n[1,]    NA  NA\n\n[[9]]\n     start end\n[1,]     6   9\n\n[[10]]\n     start end\n[1,]    NA  NA\n\n[[11]]\n     start end\n[1,]    NA  NA\n\n[[12]]\n     start end\n[1,]    NA  NA\n\n[[13]]\n     start end\n[1,]    NA  NA\n\n[[14]]\n     start end\n[1,]    NA  NA\n\n[[15]]\n     start end\n[1,]    NA  NA\n\n[[16]]\n     start end\n[1,]    NA  NA\n\n[[17]]\n     start end\n[1,]    NA  NA\n\n[[18]]\n     start end\n[1,]     1   1\n[2,]    10  10\n[3,]    13  13\n```\n:::\n\n```{.r .cell-code}\n(y <- unlist(x) |> matrix(ncol=2, byrow=TRUE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      [,1] [,2]\n [1,]   NA   NA\n [2,]   NA   NA\n [3,]   NA   NA\n [4,]   NA   NA\n [5,]   NA   NA\n [6,]    2   14\n [7,]    4   16\n [8,]   NA   NA\n [9,]   NA   NA\n[10,]    6    9\n[11,]   NA   NA\n[12,]   NA   NA\n[13,]   NA   NA\n[14,]   NA   NA\n[15,]   NA   NA\n[16,]   NA   NA\n[17,]   NA   NA\n[18,]   NA   NA\n[19,]    1   10\n[20,]   13    1\n[21,]   10   13\n```\n:::\n:::\n\n\nYea.. duplicate values of the same number makes for additional rows in the matrix. But then why didn't it mess up with my examples? ðŸ¤” \n\nOkay well let's use `head` and `tail` via `lapply` to pull the first and last rows out of each list element. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- stri_locate_all_regex(input[is.miss[1]], valid)\nx.first <- lapply(x, head, 1) |> unlist() |> matrix(ncol=2, byrow=TRUE)\nx.last  <- lapply(x, tail, 1) |> unlist() |> matrix(ncol=2, byrow=TRUE)\nfirst <- which.min(x.first[,1])\nlast  <- which.max(x.last[,2])\nas.numeric(paste0(valid.num[first], valid.num[last]))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 96\n```\n:::\n\n```{.r .cell-code}\ninput[is.miss[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"9sixqnine9jk9six\"\n```\n:::\n:::\n\n\nThird time is the charm? ðŸ¤ž\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(new.cal.vals, x, first, last, i, y, N) # just cos\nN <- length(input)\nnew.cal.vals <- rep(0, N)\nfor(i in 1:N){\n\tx <- stri_locate_all_regex(input[i], valid)\n\tx.first <- lapply(x, head, 1) |> unlist() |> matrix(ncol=2, byrow=TRUE)\n\tx.last  <- lapply(x, tail, 1) |> unlist() |> matrix(ncol=2, byrow=TRUE)\n\tfirst <- which.min(x.first[,1])\n\tlast  <- which.max(x.last[,2])\n\tnew.cal.vals[i] <- as.numeric(paste0(valid.num[first], valid.num[last]))\n}\nsum(new.cal.vals)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 54824\n```\n:::\n:::\n\n\nâ­â­\n\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\nâ”€ Session info â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n setting  value\n version  R version 4.3.1 (2023-06-16 ucrt)\n os       Windows 11 x64 (build 22000)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  English_United States.utf8\n ctype    English_United States.utf8\n tz       America/Los_Angeles\n date     2023-12-02\n pandoc   3.1.1 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\nâ”€ Packages â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n package    * version    date (UTC) lib source\n aochelpers * 0.1.0.9000 2023-11-30 [1] Github (EllaKaye/aochelpers@c2afc01)\n stringi    * 1.7.12     2023-01-11 [1] CRAN (R 4.3.0)\n stringr    * 1.5.0      2022-12-02 [1] CRAN (R 4.3.1)\n\n [1] C:/Users/renta/AppData/Local/R/win-library/4.3\n [2] C:/Program Files/R/R-4.3.1/library\n\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n```\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}